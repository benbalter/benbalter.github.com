/**
 * Next.js-specific SEO tests
 * 
 * These tests validate SEO metadata generated by Next.js Metadata API
 * and complement the general seo.spec.ts tests with Next.js-specific features
 */

import { test, expect } from '@playwright/test';
import { waitForPageReady } from './helpers';

test.describe('Next.js SEO Features', () => {
  test.describe('Core HTML Meta Tags', () => {
    test('should have UTF-8 charset declaration', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const charset = page.locator('meta[charset]');
      await expect(charset).toHaveCount(1);
      
      const charsetValue = await charset.getAttribute('charset');
      expect(charsetValue?.toLowerCase()).toBe('utf-8');
    });

    test('should have viewport meta tag for responsive design', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const viewport = page.locator('meta[name="viewport"]');
      await expect(viewport).toHaveCount(1);
      
      const content = await viewport.getAttribute('content');
      expect(content).toContain('width=device-width');
      expect(content).toContain('initial-scale=1');
    });

    test('should have theme-color meta tags', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const themeColors = page.locator('meta[name="theme-color"]');
      const count = await themeColors.count();
      
      // Should have theme colors for light and dark modes
      expect(count).toBeGreaterThanOrEqual(1);
    });

    test('should have X-UA-Compatible meta tag for IE', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const compatibility = page.locator('meta[http-equiv="X-UA-Compatible"]');
      await expect(compatibility).toHaveCount(1);
      
      const content = await compatibility.getAttribute('content');
      expect(content).toContain('IE=edge');
    });
  });

  test.describe('Open Graph Images', () => {
    const pages = [
      { url: '/about/', name: 'About page' },
      { url: '/resume/', name: 'Resume page' },
    ];

    pages.forEach(({ url, name }) => {
      test(`${name} should have Open Graph image tags`, async ({ page }) => {
        await page.goto(url);
        await waitForPageReady(page);

        const ogImage = page.locator('meta[property="og:image"]');
        await expect(ogImage).toHaveCount(1);
        
        const imageUrl = await ogImage.getAttribute('content');
        expect(imageUrl).toBeTruthy();
        expect(imageUrl).toMatch(/^https?:\/\//); // Should be absolute URL
        
        // Should have og:image:alt for accessibility
        const ogImageAlt = page.locator('meta[property="og:image:alt"]');
        const altCount = await ogImageAlt.count();
        if (altCount > 0) {
          const altText = await ogImageAlt.getAttribute('content');
          expect(altText).toBeTruthy();
        }
      });

      test(`${name} should have Twitter image tags`, async ({ page }) => {
        await page.goto(url);
        await waitForPageReady(page);

        const twitterImage = page.locator('meta[name="twitter:image"]');
        const count = await twitterImage.count();
        
        if (count > 0) {
          const imageUrl = await twitterImage.getAttribute('content');
          expect(imageUrl).toBeTruthy();
          expect(imageUrl).toMatch(/^https?:\/\//); // Should be absolute URL
        }
      });
    });
  });

  test.describe('Author and Creator Metadata', () => {
    test('should have author metadata', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const author = page.locator('meta[name="author"]');
      await expect(author).toHaveCount(1);
      
      const authorName = await author.getAttribute('content');
      expect(authorName).toBeTruthy();
      expect(authorName?.length).toBeGreaterThan(0);
    });

    test('should have creator metadata', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const creator = page.locator('meta[name="creator"]');
      await expect(creator).toHaveCount(1);
      
      const creatorName = await creator.getAttribute('content');
      expect(creatorName).toBeTruthy();
    });

    test('should have publisher metadata', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const publisher = page.locator('meta[name="publisher"]');
      await expect(publisher).toHaveCount(1);
      
      const publisherName = await publisher.getAttribute('content');
      expect(publisherName).toBeTruthy();
    });
  });

  test.describe('Structured Data (JSON-LD)', () => {
    test('homepage should have Person schema', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const jsonLd = page.locator('script[type="application/ld+json"]');
      const count = await jsonLd.count();
      expect(count).toBeGreaterThan(0);

      const content = await jsonLd.first().textContent();
      expect(content).toBeTruthy();
      
      const data = JSON.parse(content!);
      expect(data['@context']).toBe('https://schema.org');
      expect(data['@type']).toBe('Person');
      expect(data.name).toBeTruthy();
      expect(data.url).toBeTruthy();
      
      // Should have social links
      expect(data.sameAs).toBeDefined();
      expect(Array.isArray(data.sameAs)).toBeTruthy();
    });

    test('blog posts should have Article schema', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);
      
      // Find first blog post link
      const postLinks = page.locator('a[href*="/20"]');
      const count = await postLinks.count();
      
      if (count === 0) {
        test.skip(true, 'No blog posts found');
        return;
      }
      
      const firstPostUrl = await postLinks.first().getAttribute('href');
      
      if (firstPostUrl) {
        await page.goto(firstPostUrl);
        await waitForPageReady(page);
        
        const jsonLd = page.locator('script[type="application/ld+json"]');
        const jsonCount = await jsonLd.count();
        expect(jsonCount).toBeGreaterThan(0);
        
        // Look for BlogPosting schema
        let foundArticle = false;
        for (let i = 0; i < jsonCount; i++) {
          const content = await jsonLd.nth(i).textContent();
          if (content) {
            const data = JSON.parse(content);
            if (data['@type'] === 'BlogPosting') {
              foundArticle = true;
              
              // Validate required fields
              expect(data['@context']).toBe('https://schema.org');
              expect(data.headline).toBeTruthy();
              expect(data.datePublished).toBeTruthy();
              expect(data.author).toBeDefined();
              expect(data.author['@type']).toBe('Person');
              expect(data.author.name).toBeTruthy();
              
              break;
            }
          }
        }
        
        expect(foundArticle).toBeTruthy();
      }
    });
  });

  test.describe('Social Media Links (rel="me")', () => {
    test('should have rel="me" links for social profiles', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const relMeLinks = page.locator('link[rel="me"]');
      const count = await relMeLinks.count();
      
      // Should have multiple social media links
      expect(count).toBeGreaterThan(0);
      
      // Verify each link has a valid href
      for (let i = 0; i < count; i++) {
        const href = await relMeLinks.nth(i).getAttribute('href');
        expect(href).toBeTruthy();
        expect(href).toMatch(/^https?:\/\//);
      }
    });
  });

  test.describe('RSS/Feed Metadata', () => {
    test('should have RSS feed alternate link', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const rssLink = page.locator('link[rel="alternate"][type="application/rss+xml"]');
      await expect(rssLink).toHaveCount(1);
      
      const href = await rssLink.getAttribute('href');
      expect(href).toBeTruthy();
      expect(href).toContain('feed.xml');
    });
  });

  test.describe('Favicon and Icons', () => {
    test('should have favicon links', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      // Check for various favicon formats
      const icons = [
        'link[rel="icon"][href="/favicon-32x32.png"]',
        'link[rel="icon"][href="/favicon-16x16.png"]',
        'link[rel="shortcut icon"][href="/favicon.ico"]',
        'link[rel="apple-touch-icon"]',
      ];

      for (const selector of icons) {
        const icon = page.locator(selector);
        const count = await icon.count();
        expect(count).toBeGreaterThanOrEqual(1);
      }
    });

    test('should have web manifest link', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const manifest = page.locator('link[rel="manifest"]');
      await expect(manifest).toHaveCount(1);
      
      const href = await manifest.getAttribute('href');
      expect(href).toBe('/site.webmanifest');
    });
  });

  test.describe('Blog Post SEO', () => {
    test('blog posts should have article-specific Open Graph tags', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);
      
      const postLinks = page.locator('a[href*="/20"]');
      const count = await postLinks.count();
      
      if (count === 0) {
        test.skip(true, 'No blog posts found');
        return;
      }
      
      const firstPostUrl = await postLinks.first().getAttribute('href');
      
      if (firstPostUrl) {
        await page.goto(firstPostUrl);
        await waitForPageReady(page);
        
        // Check for article type
        const ogType = page.locator('meta[property="og:type"]');
        const typeContent = await ogType.getAttribute('content');
        expect(typeContent).toBe('article');
        
        // Check for published time
        const publishedTime = page.locator('meta[property="og:published_time"], meta[property="article:published_time"]');
        const publishedCount = await publishedTime.count();
        
        if (publishedCount > 0) {
          const time = await publishedTime.first().getAttribute('content');
          expect(time).toBeTruthy();
          
          // Should be a valid ISO date
          const date = new Date(time!);
          expect(date.toString()).not.toBe('Invalid Date');
        }
      }
    });

    test('blog posts should have proper Twitter Card type', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);
      
      const postLinks = page.locator('a[href*="/20"]');
      const count = await postLinks.count();
      
      if (count === 0) {
        test.skip(true, 'No blog posts found');
        return;
      }
      
      const firstPostUrl = await postLinks.first().getAttribute('href');
      
      if (firstPostUrl) {
        await page.goto(firstPostUrl);
        await waitForPageReady(page);
        
        const twitterCard = page.locator('meta[name="twitter:card"]');
        const cardType = await twitterCard.getAttribute('content');
        
        // Blog posts should use summary_large_image for better social previews
        expect(cardType).toBeTruthy();
        expect(['summary', 'summary_large_image']).toContain(cardType);
      }
    });
  });

  test.describe('Keywords and SEO Metadata', () => {
    test('should have keywords meta tag', async ({ page }) => {
      await page.goto('/');
      await waitForPageReady(page);

      const keywords = page.locator('meta[name="keywords"]');
      await expect(keywords).toHaveCount(1);
      
      const content = await keywords.getAttribute('content');
      expect(content).toBeTruthy();
      expect(content!.length).toBeGreaterThan(0);
    });
  });

  test.describe('Robots and Indexing', () => {
    test('main pages should be indexable', async ({ page }) => {
      const pages = ['/', '/about/', '/resume/'];
      
      for (const url of pages) {
        await page.goto(url);
        await waitForPageReady(page);
        
        const robotsMeta = page.locator('meta[name="robots"]');
        const count = await robotsMeta.count();
        
        if (count > 0) {
          const content = await robotsMeta.getAttribute('content');
          expect(content).toContain('index');
          expect(content).toContain('follow');
        }
        
        // Check for googlebot-specific meta
        const googlebotMeta = page.locator('meta[name="googlebot"]');
        const googlebotCount = await googlebotMeta.count();
        
        if (googlebotCount > 0) {
          const googlebotContent = await googlebotMeta.getAttribute('content');
          expect(googlebotContent).toContain('index');
          expect(googlebotContent).toContain('follow');
        }
      }
    });
  });
});

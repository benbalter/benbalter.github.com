---
/**
 * TL;DR Component
 * 
 * Displays a "Too Long; Didn't Read" summary with tooltip explanation.
 * Matches the Jekyll tldr.html include functionality with markdown support.
 */

import { marked } from 'marked';

interface Props {
  description: string;
}

const { description } = Astro.props;

const tooltipTitle = '"Too Long; Didn\'t Read" â€” Internet shorthand for "a brief summary of longer writing"';
---

<div class="lead">
  <strong><abbr class="initialism" data-tooltip="true" data-tooltip-text={tooltipTitle}>TL;DR</abbr>:</strong>{' '}
  <span set:html={marked.parseInline(description)} />
</div>

<script>
  // Lightweight custom tooltip implementation (no Bootstrap dependency)
  document.addEventListener('DOMContentLoaded', () => {
    const tooltipElements = document.querySelectorAll('[data-tooltip="true"]:not([data-tooltip-initialized])');
    
    // Tooltip transition duration (should match CSS transition)
    const TOOLTIP_CLEANUP_TIMEOUT = 300; // Fallback timeout with buffer
    
    // Track active tooltips for click-outside handler
    const activeTooltips = new Map<HTMLElement, HTMLDivElement>();
    
    // Global click handler for click-outside functionality
    const handleGlobalClick = (e: MouseEvent) => {
      const target = e.target;
      if (!target) return;
      
      activeTooltips.forEach((tooltipEl, element) => {
        if (!element.contains(target as Node)) {
          hideTooltip(element);
        }
      });
    };
    
    // Function to show tooltip
    const showTooltip = (target: HTMLElement) => {
      // If tooltip already exists for this element, don't create another
      if (activeTooltips.has(target)) return;
      
      const tooltipText = target.getAttribute('data-tooltip-text');
      
      if (!tooltipText) return;
      
      // Create tooltip element
      const tooltipEl = document.createElement('div');
      tooltipEl.className = 'custom-tooltip';
      tooltipEl.textContent = tooltipText;
      document.body.appendChild(tooltipEl);
      
      // Track this tooltip
      activeTooltips.set(target, tooltipEl);
      
      // Position tooltip to the right of the element
      // Use requestAnimationFrame to ensure DOM has updated
      requestAnimationFrame(() => {
        const rect = target.getBoundingClientRect();
        const tooltipRect = tooltipEl.getBoundingClientRect();
        tooltipEl.style.left = `${rect.right + 10}px`;
        tooltipEl.style.top = `${rect.top + (rect.height / 2) - (tooltipRect.height / 2)}px`;
        
        // Fade in using requestAnimationFrame for better performance
        requestAnimationFrame(() => {
          tooltipEl.classList.add('show');
        });
      });
    };
    
    // Function to hide tooltip
    const hideTooltip = (target: HTMLElement) => {
      const tooltipEl = activeTooltips.get(target);
      if (!tooltipEl) return;
      
      // Remove from active list immediately to prevent duplicate hide calls
      activeTooltips.delete(target);
      
      tooltipEl.classList.remove('show');
      
      // Track if cleanup has been executed
      let cleanupExecuted = false;
      
      // Cleanup function
      const cleanup = () => {
        if (cleanupExecuted) return;
        cleanupExecuted = true;
        
        tooltipEl.remove();
      };
      
      // Use transitionend event for proper cleanup timing
      const handleTransitionEnd = () => {
        cleanup();
      };
      
      tooltipEl.addEventListener('transitionend', handleTransitionEnd, { once: true });
      
      // Fallback timeout in case transitionend doesn't fire
      // Timeout is longer than CSS transition (0.2s) to ensure transition completes
      setTimeout(() => {
        tooltipEl.removeEventListener('transitionend', handleTransitionEnd);
        cleanup();
      }, TOOLTIP_CLEANUP_TIMEOUT);
    };
    
    tooltipElements.forEach((element) => {
      // Mark as initialized
      element.setAttribute('data-tooltip-initialized', 'true');
      
      // Show tooltip on mouseenter (for desktop)
      element.addEventListener('mouseenter', (e) => {
        const target = e.currentTarget as HTMLElement;
        showTooltip(target);
      });
      
      // Hide tooltip on mouseleave (for desktop)
      element.addEventListener('mouseleave', () => {
        hideTooltip(element as HTMLElement);
      });
      
      // Toggle tooltip on click/tap (for mobile and accessibility)
      element.addEventListener('click', (e) => {
        // Stop propagation to prevent global click handler from firing
        e.stopPropagation();
        
        const target = e.currentTarget as HTMLElement;
        
        // Always toggle: if visible, hide it; if hidden, show it
        if (activeTooltips.has(target)) {
          hideTooltip(target);
        } else {
          showTooltip(target);
        }
      });
    });
    
    // Add single global click handler for click-outside functionality
    // This prevents memory leaks by using one handler for all tooltips
    // The handler will be cleaned up when the page unloads
    if (tooltipElements.length > 0) {
      document.addEventListener('click', handleGlobalClick);
    }
  });
</script>

<style>
  .lead {
    font-size: 1.25rem;
    font-weight: 300;
  }

  .initialism {
    text-decoration: none;
    cursor: help;
    border-bottom: 1px dotted currentColor;
  }

  /* Custom tooltip styles */
  :global(.custom-tooltip) {
    position: fixed;
    background-color: #000;
    color: #fff;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 0.875rem;
    line-height: 1.4;
    max-width: 300px;
    z-index: 1050;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    pointer-events: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }

  :global(.custom-tooltip.show) {
    opacity: 0.9;
  }

  :global(.custom-tooltip::before) {
    content: '';
    position: absolute;
    right: 100%;
    top: 50%;
    transform: translateY(-50%);
    border: 5px solid transparent;
    border-right-color: #000;
  }
</style>

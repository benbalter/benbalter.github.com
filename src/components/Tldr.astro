---
/**
 * TL;DR Component
 * 
 * Displays a "Too Long; Didn't Read" summary with tooltip explanation.
 * Uses Bootstrap .lead class for prominent display.
 * Matches the Jekyll tldr.html include functionality with markdown support.
 */

import { marked } from 'marked';

interface Props {
  description: string;
}

const { description } = Astro.props;

const tooltipTitle = '"Too Long; Didn\'t Read" â€” Internet shorthand for "a brief summary of longer writing"';
---

<div class="lead">
  <strong><abbr class="initialism" data-tooltip="true" data-tooltip-text={tooltipTitle} role="button" aria-expanded="false" tabindex="0">TL;DR</abbr>:</strong>{' '}
  <span set:html={marked.parseInline(description)} />
</div>

<script>
  // Lightweight custom tooltip implementation (no Bootstrap dependency)
  // Track if global handler has been added (for cleanup in SPAs)
  let globalClickHandlerAdded = false;
  
  // Global click handler for click-outside functionality (defined outside DOMContentLoaded for cleanup)
  const handleGlobalClick = (e: MouseEvent) => {
    const target = e.target;
    if (!target) return;
    
    const activeTooltips = (window as any).__tldrActiveTooltips;
    if (!activeTooltips) return;
    
    activeTooltips.forEach((tooltipEl: HTMLDivElement, element: HTMLElement) => {
      if (!element.contains(target as Node)) {
        hideTooltip(element);
      }
    });
  };
  
  // Function to show tooltip
  const showTooltip = (target: HTMLElement) => {
    const activeTooltips = (window as any).__tldrActiveTooltips;
    
    // If tooltip already exists for this element, don't create another
    if (activeTooltips.has(target)) return;
    
    const tooltipText = target.getAttribute('data-tooltip-text');
    
    if (!tooltipText) return;
    
    // Create tooltip element
    const tooltipEl = document.createElement('div');
    tooltipEl.className = 'custom-tooltip';
    tooltipEl.textContent = tooltipText;
    tooltipEl.id = `tooltip-${Math.random().toString(36).substr(2, 9)}`;
    tooltipEl.setAttribute('role', 'tooltip');
    document.body.appendChild(tooltipEl);
    
    // Set ARIA attributes
    target.setAttribute('aria-describedby', tooltipEl.id);
    target.setAttribute('aria-expanded', 'true');
    
    // Track this tooltip
    activeTooltips.set(target, tooltipEl);
    
    // Position tooltip with viewport boundary checks
    requestAnimationFrame(() => {
      const rect = target.getBoundingClientRect();
      const tooltipRect = tooltipEl.getBoundingClientRect();
      
      // Default: position to the right
      let left = rect.right + 10;
      let top = rect.top + (rect.height / 2) - (tooltipRect.height / 2);
      
      // Check if tooltip would overflow right edge of viewport
      if (left + tooltipRect.width > window.innerWidth) {
        // Position to the left instead
        left = rect.left - tooltipRect.width - 10;
        tooltipEl.classList.add('left');
      } else {
        tooltipEl.classList.remove('left');
      }
      
      // Clamp top so tooltip doesn't overflow top or bottom
      top = Math.max(10, Math.min(top, window.innerHeight - tooltipRect.height - 10));
      
      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
      
      // Fade in using requestAnimationFrame for better performance
      requestAnimationFrame(() => {
        tooltipEl.classList.add('show');
      });
    });
  };
  
  // Function to hide tooltip
  const hideTooltip = (target: HTMLElement) => {
    const activeTooltips = (window as any).__tldrActiveTooltips;
    const tooltipEl = activeTooltips.get(target);
    if (!tooltipEl) return;
    
    // Clear ARIA attributes
    target.removeAttribute('aria-describedby');
    target.setAttribute('aria-expanded', 'false');
    
    // Remove from active list immediately to prevent duplicate hide calls
    activeTooltips.delete(target);
    
    tooltipEl.classList.remove('show');
    
    // Track if cleanup has been executed
    let cleanupExecuted = false;
    
    // Cleanup function
    const cleanup = () => {
      if (cleanupExecuted) return;
      cleanupExecuted = true;
      
      tooltipEl.remove();
    };
    
    // Use transitionend event for proper cleanup timing
    const handleTransitionEnd = () => {
      cleanup();
    };
    
    tooltipEl.addEventListener('transitionend', handleTransitionEnd, { once: true });
    
    // Fallback timeout in case transitionend doesn't fire
    // Timeout is longer than CSS transition (0.2s) to ensure transition completes
    setTimeout(() => {
      tooltipEl.removeEventListener('transitionend', handleTransitionEnd);
      cleanup();
    }, 300);
  };
  
  // Initialize tooltips function (called on page load and after navigation)
  const initializeTooltips = () => {
    const tooltipElements = document.querySelectorAll('[data-tooltip="true"]:not([data-tooltip-initialized])');
    
    // Initialize global activeTooltips map
    if (!(window as any).__tldrActiveTooltips) {
      (window as any).__tldrActiveTooltips = new Map<HTMLElement, HTMLDivElement>();
    }
    
    tooltipElements.forEach((element) => {
      // Mark as initialized
      element.setAttribute('data-tooltip-initialized', 'true');
      
      // Only add hover listeners on devices with hover capability
      if (window.matchMedia('(hover: hover)').matches) {
        // Show tooltip on mouseenter (for desktop)
        element.addEventListener('mouseenter', (e) => {
          const target = e.currentTarget as HTMLElement;
          showTooltip(target);
        });
        
        // Hide tooltip on mouseleave (for desktop)
        element.addEventListener('mouseleave', () => {
          hideTooltip(element as HTMLElement);
        });
      }
      
      // Toggle tooltip on click/tap (for mobile and accessibility)
      element.addEventListener('click', (e) => {
        // Stop propagation to prevent global click handler from firing
        e.stopPropagation();
        
        const target = e.currentTarget as HTMLElement;
        const activeTooltips = (window as any).__tldrActiveTooltips;
        
        // Always toggle: if visible, hide it; if hidden, show it
        if (activeTooltips.has(target)) {
          hideTooltip(target);
        } else {
          showTooltip(target);
        }
      });
      
      // Add keyboard support (Enter, Space to toggle, Escape to close)
      element.addEventListener('keydown', (e) => {
        const keyEvent = e as KeyboardEvent;
        const target = e.currentTarget as HTMLElement;
        const activeTooltips = (window as any).__tldrActiveTooltips;
        
        if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
          keyEvent.preventDefault();
          if (activeTooltips.has(target)) {
            hideTooltip(target);
          } else {
            showTooltip(target);
          }
        } else if (keyEvent.key === 'Escape' && activeTooltips.has(target)) {
          hideTooltip(target);
        }
      });
    });
    
    // Add single global click handler for click-outside functionality
    // This prevents memory leaks by using one handler for all tooltips
    if (tooltipElements.length > 0 && !globalClickHandlerAdded) {
      document.addEventListener('click', handleGlobalClick);
      globalClickHandlerAdded = true;
    }
  };
  
  // Initialize on initial page load (first time or full page reload)
  document.addEventListener('DOMContentLoaded', initializeTooltips);
  
  // Initialize after Astro View Transitions navigation (SPA-style navigation)
  document.addEventListener('astro:page-load', initializeTooltips);
  
  // Clean up before Astro View Transitions navigation (for SPAs)
  document.addEventListener('astro:before-preparation', () => {
    if (globalClickHandlerAdded) {
      document.removeEventListener('click', handleGlobalClick);
      globalClickHandlerAdded = false;
    }
  });
</script>

<style>
  /* Custom styles for initialism (Bootstrap doesn't include this) */
  .initialism {
    text-decoration: none;
    cursor: help;
    border-bottom: 1px dotted currentColor;
  }

  /* Custom tooltip styles (Bootstrap's tooltip requires JavaScript initialization) */
  :global(.custom-tooltip) {
    position: fixed;
    background-color: var(--bs-dark, #212529);
    color: var(--bs-light, #f8f9fa);
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 0.875rem;
    line-height: 1.4;
    max-width: 300px;
    z-index: 1050;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    pointer-events: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }

  :global(.custom-tooltip.show) {
    opacity: 0.9;
  }

  /* Arrow pointing left (default - tooltip on right side) */
  :global(.custom-tooltip::before) {
    content: '';
    position: absolute;
    right: 100%;
    top: 50%;
    transform: translateY(-50%);
    border: 5px solid transparent;
    border-right-color: var(--bs-dark, #212529);
  }

  /* Dark mode tooltip adjustments */
  @media (prefers-color-scheme: dark) {
    :global(.custom-tooltip) {
      background-color: var(--bs-light, #f8f9fa);
      color: var(--bs-dark, #212529);
      box-shadow: 0 2px 8px rgba(255, 255, 255, 0.15);
    }
    
    :global(.custom-tooltip::before) {
      border-right-color: var(--bs-light, #f8f9fa);
    }
  }
  
  /* Arrow pointing right (when tooltip is on left side) */
  :global(.custom-tooltip.left::before) {
    right: auto;
    left: 100%;
    border-right-color: transparent;
    border-left-color: #000;
  }
</style>

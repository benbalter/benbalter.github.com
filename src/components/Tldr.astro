---
/**
 * TL;DR Component
 * 
 * Displays a "Too Long; Didn't Read" summary with tooltip explanation.
 * Uses Tailwind CSS for styling with custom tooltip implementation.
 * Matches the Jekyll tldr.html include functionality with markdown support.
 */

import { marked } from 'marked';

interface Props {
  description: string;
}

const { description } = Astro.props;

const tooltipTitle = '"Too Long; Didn\'t Read" â€” Internet shorthand for "a brief summary of longer writing"';
---

<div class="tldr-container text-lg">
  <div class="tldr-icon">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <circle cx="12" cy="12" r="10"></circle>
      <path d="M12 16v-4"></path>
      <path d="M12 8h.01"></path>
    </svg>
  </div>
  <div class="tldr-content">
    <strong><abbr class="initialism" data-tooltip="true" data-tooltip-text={tooltipTitle} role="button" aria-expanded="false" tabindex="0">TL;DR</abbr>:</strong>{' '}
    <span set:html={marked.parseInline(description)} />
  </div>
</div>

<script>
  // Lightweight custom tooltip implementation (no Bootstrap dependency)
  // Track if global handlers have been added (for cleanup in SPAs)
  let globalClickHandlerAdded = false;
  let globalScrollHandlerAdded = false;
  
  // Global click handler for click-outside functionality (defined outside DOMContentLoaded for cleanup)
  const handleGlobalClick = (e: MouseEvent) => {
    const target = e.target;
    if (!target) return;
    
    const activeTooltips = (window as any).__tldrActiveTooltips;
    if (!activeTooltips) return;
    
    activeTooltips.forEach((_tooltipEl: HTMLDivElement, element: HTMLElement) => {
      if (!element.contains(target as Node)) {
        hideTooltip(element);
      }
    });
  };
  
  // Global scroll handler to hide tooltips when scrolling
  const handleGlobalScroll = () => {
    const activeTooltips = (window as any).__tldrActiveTooltips;
    if (!activeTooltips || activeTooltips.size === 0) return;
    
    activeTooltips.forEach((_tooltipEl: HTMLDivElement, element: HTMLElement) => {
      hideTooltip(element);
    });
  };
  
  // Function to show tooltip
  const showTooltip = (target: HTMLElement) => {
    const activeTooltips = (window as any).__tldrActiveTooltips;
    
    // If tooltip already exists for this element, don't create another
    if (activeTooltips.has(target)) return;
    
    const tooltipText = target.getAttribute('data-tooltip-text');
    
    if (!tooltipText) return;
    
    // Create tooltip element
    const tooltipEl = document.createElement('div');
    tooltipEl.className = 'custom-tooltip';
    tooltipEl.textContent = tooltipText;
    tooltipEl.id = `tooltip-${Math.random().toString(36).substring(2, 11)}`;
    tooltipEl.setAttribute('role', 'tooltip');
    document.body.appendChild(tooltipEl);
    
    // Set ARIA attributes
    target.setAttribute('aria-describedby', tooltipEl.id);
    target.setAttribute('aria-expanded', 'true');
    
    // Track this tooltip
    activeTooltips.set(target, tooltipEl);
    
    // Position tooltip with viewport boundary checks
    requestAnimationFrame(() => {
      const rect = target.getBoundingClientRect();
      const tooltipRect = tooltipEl.getBoundingClientRect();
      
      // Default: position to the right, vertically centered on the target
      let left = rect.right + 10;
      let top = rect.top + (rect.height / 2) - (tooltipRect.height / 2);
      
      // Check if tooltip would overflow right edge of viewport
      if (left + tooltipRect.width > window.innerWidth) {
        // Try positioning to the left instead
        const leftPosition = rect.left - tooltipRect.width - 10;
        
        if (leftPosition >= 10) {
          left = leftPosition;
          tooltipEl.classList.add('left');
          tooltipEl.classList.remove('below');
        } else {
          // Not enough horizontal space on either side:
          // fall back to centering the tooltip below the target
          tooltipEl.classList.remove('left');
          tooltipEl.classList.add('below');
          
          left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
          left = Math.max(10, Math.min(left, window.innerWidth - tooltipRect.width - 10));
          
          top = rect.bottom + 10;
        }
      } else {
        tooltipEl.classList.remove('left');
        tooltipEl.classList.remove('below');
      }
      
      // Clamp top so tooltip doesn't overflow top or bottom
      top = Math.max(10, Math.min(top, window.innerHeight - tooltipRect.height - 10));
      
      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
      
      // Fade in using requestAnimationFrame for better performance
      requestAnimationFrame(() => {
        tooltipEl.classList.add('show');
      });
    });
  };
  
  // Function to hide tooltip
  const hideTooltip = (target: HTMLElement) => {
    const activeTooltips = (window as any).__tldrActiveTooltips;
    const tooltipEl = activeTooltips.get(target);
    if (!tooltipEl) return;
    
    // Clear ARIA attributes
    target.removeAttribute('aria-describedby');
    target.setAttribute('aria-expanded', 'false');
    
    // Remove from active list immediately to prevent duplicate hide calls
    activeTooltips.delete(target);
    
    tooltipEl.classList.remove('show');
    
    // Track if cleanup has been executed
    let cleanupExecuted = false;
    
    // Cleanup function
    const cleanup = () => {
      if (cleanupExecuted) return;
      cleanupExecuted = true;
      
      tooltipEl.remove();
    };
    
    // Use transitionend event for proper cleanup timing
    const handleTransitionEnd = () => {
      cleanup();
    };
    
    tooltipEl.addEventListener('transitionend', handleTransitionEnd, { once: true });
    
    // Fallback timeout in case transitionend doesn't fire
    // Timeout is longer than CSS transition (0.2s) to ensure transition completes
    setTimeout(() => {
      tooltipEl.removeEventListener('transitionend', handleTransitionEnd);
      cleanup();
    }, 300);
  };
  
  // Initialize tooltips function (called on page load and after navigation)
  const initializeTooltips = () => {
    const tooltipElements = document.querySelectorAll('[data-tooltip="true"]:not([data-tooltip-initialized])');
    
    // Initialize global activeTooltips map
    if (!(window as any).__tldrActiveTooltips) {
      (window as any).__tldrActiveTooltips = new Map<HTMLElement, HTMLDivElement>();
    }
    
    tooltipElements.forEach((element) => {
      // Mark as initialized
      element.setAttribute('data-tooltip-initialized', 'true');
      
      // Only add hover listeners on devices with hover capability
      if (window.matchMedia('(hover: hover)').matches) {
        // Show tooltip on mouseenter (for desktop)
        element.addEventListener('mouseenter', (e) => {
          const target = e.currentTarget as HTMLElement;
          showTooltip(target);
        });
        
        // Hide tooltip on mouseleave (for desktop)
        element.addEventListener('mouseleave', () => {
          hideTooltip(element as HTMLElement);
        });
      }
      
      // Toggle tooltip on click/tap (for mobile and accessibility)
      element.addEventListener('click', (e) => {
        // Stop propagation to prevent global click handler from firing
        e.stopPropagation();
        
        const target = e.currentTarget as HTMLElement;
        const activeTooltips = (window as any).__tldrActiveTooltips;
        
        // Always toggle: if visible, hide it; if hidden, show it
        if (activeTooltips.has(target)) {
          hideTooltip(target);
        } else {
          showTooltip(target);
        }
      });
      
      // Add keyboard support (Enter, Space to toggle, Escape to close)
      element.addEventListener('keydown', (e) => {
        const keyEvent = e as KeyboardEvent;
        const target = e.currentTarget as HTMLElement;
        const activeTooltips = (window as any).__tldrActiveTooltips;
        
        if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
          keyEvent.preventDefault();
          if (activeTooltips.has(target)) {
            hideTooltip(target);
          } else {
            showTooltip(target);
          }
        } else if (keyEvent.key === 'Escape' && activeTooltips.has(target)) {
          hideTooltip(target);
        }
      });
    });
    
    // Add single global click handler for click-outside functionality
    // This prevents memory leaks by using one handler for all tooltips
    if (tooltipElements.length > 0 && !globalClickHandlerAdded) {
      document.addEventListener('click', handleGlobalClick);
      globalClickHandlerAdded = true;
    }
    
    // Add single global scroll handler to hide tooltips when scrolling
    // Use passive: true for better scroll performance
    if (tooltipElements.length > 0 && !globalScrollHandlerAdded) {
      window.addEventListener('scroll', handleGlobalScroll, { passive: true });
      globalScrollHandlerAdded = true;
    }
  };
  
  // Initialize on initial page load (first time or full page reload)
  document.addEventListener('DOMContentLoaded', initializeTooltips);
  
  // Initialize after Astro View Transitions navigation (SPA-style navigation)
  // Use both events for reliable initialization:
  // - astro:after-swap: fires immediately after DOM swap for fast initialization
  // - astro:page-load: fires after navigation completes as a reliable fallback
  // The initializeTooltips function is idempotent (checks for data-tooltip-initialized)
  // so calling it twice is safe and ensures no race conditions
  document.addEventListener('astro:after-swap', initializeTooltips);
  document.addEventListener('astro:page-load', initializeTooltips);
  
  // Clean up before Astro View Transitions navigation (for SPAs)
  // Use astro:before-swap for cleanup - it fires right before DOM swap
  document.addEventListener('astro:before-swap', () => {
    // Hide all active tooltips
    const activeTooltips = (window as any).__tldrActiveTooltips;
    if (activeTooltips) {
      activeTooltips.forEach((_tooltipEl: HTMLDivElement, element: HTMLElement) => {
        hideTooltip(element);
      });
    }
    
    // Remove initialization markers so elements can be reinitialized after navigation
    const tooltipElements = document.querySelectorAll('[data-tooltip-initialized]');
    tooltipElements.forEach((element) => {
      element.removeAttribute('data-tooltip-initialized');
    });
    
    // Remove global click handler
    if (globalClickHandlerAdded) {
      document.removeEventListener('click', handleGlobalClick);
      globalClickHandlerAdded = false;
    }
    
    // Remove global scroll handler
    if (globalScrollHandlerAdded) {
      window.removeEventListener('scroll', handleGlobalScroll);
      globalScrollHandlerAdded = false;
    }
  });
</script>

<style>
  :root {
    /* TL;DR tap highlight color, configurable for design system consistency */
    --tldr-tap-highlight-color: rgba(0, 0, 0, 0.1);
  }
  
  /* Enhanced TL;DR container with visual prominence */
  .tldr-container {
    position: relative;
    @apply flex items-start gap-4 p-5 my-6 rounded-lg shadow-card;
    background: linear-gradient(
      135deg,
      rgba(51, 122, 183, 0.05),
      rgba(51, 122, 183, 0.02)
    );
    border-left: 4px solid #337ab7;
  }
  
  /* Icon styling */
  .tldr-icon {
    @apply flex-shrink-0 w-6 h-6 text-primary;
    margin-top: 0.125rem;
  }
  
  .tldr-content {
    @apply flex-1;
  }
  
  /* Dark mode adjustments */
  @media (prefers-color-scheme: dark) {
    .tldr-container {
      background: linear-gradient(
        135deg,
        rgba(51, 122, 183, 0.12),
        rgba(51, 122, 183, 0.06)
      );
      @apply shadow-card-dark;
    }
  }

  /* Custom styles for initialism */
  .initialism {
    @apply no-underline cursor-help;
    border-bottom: 1px dotted currentColor;
    -webkit-tap-highlight-color: var(--tldr-tap-highlight-color);
    touch-action: manipulation;
  }
  
  /* Use pointer cursor on touch-only devices */
  @media (any-pointer: coarse) and (hover: none) {
    .initialism {
      @apply cursor-pointer;
    }
  }

  /* Custom tooltip styles */
  :global(.custom-tooltip) {
    position: fixed;
    @apply bg-gray-900 text-gray-100 px-3 py-2 rounded text-sm;
    line-height: 1.4;
    max-width: 300px;
    z-index: 1050;
    @apply opacity-0;
    transition: opacity 0.2s ease-in-out;
    pointer-events: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }

  :global(.custom-tooltip.show) {
    opacity: 0.9;
  }

  /* Arrow pointing left (default - tooltip on right side) */
  :global(.custom-tooltip::before) {
    content: '';
    position: absolute;
    right: 100%;
    top: 50%;
    transform: translateY(-50%);
    border: 5px solid transparent;
    @apply border-r-gray-900;
  }

  /* Dark mode tooltip adjustments */
  @media (prefers-color-scheme: dark) {
    :global(.custom-tooltip) {
      @apply bg-gray-100 text-gray-900;
      box-shadow: 0 2px 8px rgba(255, 255, 255, 0.15);
    }
    
    :global(.custom-tooltip::before) {
      @apply border-r-gray-100;
    }
  }
  
  /* Arrow pointing right (when tooltip is on left side) */
  :global(.custom-tooltip.left::before) {
    right: auto;
    left: 100%;
    border-right-color: transparent;
    @apply border-l-gray-900;
  }
  
  /* Dark mode: left arrow */
  @media (prefers-color-scheme: dark) {
    :global(.custom-tooltip.left::before) {
      @apply border-l-gray-100;
    }
  }
  
  /* Hide arrow when tooltip is positioned below */
  :global(.custom-tooltip.below::before) {
    @apply hidden;
  }
</style>
